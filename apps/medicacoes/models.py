from decimal import Decimalfrom django.db import models, transactionfrom django.utils import timezonefrom django.core.exceptions import ValidationError# Valores auxiliaresFREQUENCIA_CHOICES = [    ('diaria', 'Diária'),    ('2x_dia', '2x por dia'),    ('3x_dia', '3x por dia'),    ('semanal', 'Semanal'),    ('mensal', 'Mensal'),]STATUS_REGISTRO = [    ('dei', 'Dei'),    ('esqueci', 'Esqueci'),    ('vomitou', 'Vomitou'),    ('recusou', 'Recusou'),]TIPO_ALERTA = [    ('amarelo', 'Amarelo'),    ('vermelho', 'Vermelho'),    ('clinico', 'Clínico'),]class Bebe(models.Model):    nome = models.CharField(max_length=120)    data_nascimento = models.DateField()    responsavel = models.CharField(max_length=120, blank=True)    def __str__(self):        return f"{self.nome} ({self.data_nascimento.isoformat()})"class Medicacao(models.Model):    bebe = models.ForeignKey(Bebe, on_delete=models.CASCADE, related_name='medicacoes')    nome = models.CharField(max_length=200)    dosagem = models.CharField(max_length=80, help_text="Ex: 5 ml, 1 comprimido")    frequencia = models.CharField(max_length=20, choices=FREQUENCIA_CHOICES)    via = models.CharField(max_length=50, default='oral')    duracao_dias = models.IntegerField(help_text="Duração prevista em dias", null=True, blank=True)    data_inicio = models.DateField(default=timezone.now)    cuidados = models.TextField(blank=True)    def __str__(self):        return f"{self.nome} - {self.bebe.nome}"    def consumo_diario(self):        """        Estima o consumo diário com base na frequência.        Retorna um Decimal com as unidades referentes à 'quantidade' armazenada no Estoque.        Observação: a dosagem é armazenada como texto (ex: '5 ml'); este método retorna        apenas um número de 'unidades por dia' (1, 2, 3, 0.03, etc). A interpretação        exata da unidade (ml, comprimidos) fica a cargo do campo Estoque.unidade.        """        freq = self.frequencia        if freq == 'diaria':            return Decimal('1')        if freq == '2x_dia':            return Decimal('2')        if freq == '3x_dia':            return Decimal('3')        if freq == 'semanal':            return Decimal('1') / Decimal('7')        if freq == 'mensal':            return Decimal('1') / Decimal('30')        # valor default seguro        return Decimal('1')class Estoque(models.Model):    medicacao = models.OneToOneField(Medicacao, on_delete=models.CASCADE, related_name='estoque')    quantidade_total = models.DecimalField(max_digits=10, decimal_places=2,                                           help_text="Quantidade total em unidade definida (ex: ml ou comprimidos)")    unidade = models.CharField(max_length=30, default='ml')    data_atualizacao = models.DateTimeField(auto_now=True)    def __str__(self):        return f"Estoque {self.medicacao.nome} ({self.quantidade_total} {self.unidade})"    def dias_restantes(self):        """        Calcula o número estimado de dias restantes com base no consumo diário do medicamento.        """        consumo = self.medicacao.consumo_diario()        try:            if consumo <= 0:                return None            dias = Decimal(self.quantidade_total) / consumo            return dias        except Exception:            return None    def verificar_estoque(self):        """        Se restarem menos de 3 dias, cria ou atualiza um alerta do tipo 'amarelo' para o bebê.        """        dias = self.dias_restantes()        if dias is None:            return None        if dias < 3:            descricao = f"Estoque baixo para {self.medicacao.nome}: ~{dias:.1f} dias restantes"            alerta, created = Alerta.objects.get_or_create(                bebe=self.medicacao.bebe,                tipo='amarelo',                descricao=descricao,                status='pendente'            )            return alerta        return Noneclass Lembrete(models.Model):    medicacao = models.ForeignKey(Medicacao, on_delete=models.CASCADE, related_name='lembretes')    horario = models.TimeField()    canal = models.CharField(max_length=20, default='app', help_text="app, sms, whatsapp")    def __str__(self):        return f"Lembrete {self.medicacao.nome} - {self.horario.isoformat()}"class RegistroAdministracao(models.Model):    medicacao = models.ForeignKey(Medicacao, on_delete=models.CASCADE, related_name='registros')    data = models.DateField(default=timezone.now)    horario = models.TimeField(default=timezone.now)    status = models.CharField(max_length=20, choices=STATUS_REGISTRO)    observacoes = models.TextField(blank=True)    criado_em = models.DateTimeField(auto_now_add=True)    class Meta:        ordering = ['-criado_em']    def __str__(self):        return f"{self.medicacao.nome} - {self.data} {self.horario} - {self.status}"    def save(self, *args, **kwargs):        """        Ao salvar um registro, chamar verificações de alerta e atualizar estoque.        """        with transaction.atomic():            super().save(*args, **kwargs)            # Atualiza estoque quando registro for 'dei'            if self.status == 'dei':                estoque = getattr(self.medicacao, 'estoque', None)                if estoque:                    # diminui quantidade_total em 1 unidade equivalente ao consumo diário                    consumo = self.medicacao.consumo_diario()                    try:                        estoque.quantidade_total = Decimal(estoque.quantidade_total) - consumo                        if estoque.quantidade_total < 0:                            estoque.quantidade_total = Decimal('0')                        estoque.save()                    except Exception:                        pass            # verificar alertas relacionados a esquecimentos            self.verificar_alertas()            # verificar estoque também            estoque = getattr(self.medicacao, 'estoque', None)            if estoque:                estoque.verificar_estoque()    def verificar_alertas(self):        """        Verifica se existem 2 ou 3 esquecimentos consecutivos para gerar alertas.        - 2 esquecimentos consecutivos -> alerta amarelo        - 3 ou mais esquecimentos consecutivos -> alerta vermelho        Observação: a checagem é feita sobre os registros mais recentes para a mesma medicação.        """        # buscar registros recentes para a mesma medicação (ordenados do mais novo)        registros = RegistroAdministracao.objects.filter(            medicacao=self.medicacao        ).order_by('-criado_em')[:10]  # olhar até 10 registros recentes        # contar sequencia inicial de 'esqueci'        contador_esquecidos = 0        for reg in registros:            if reg.status == 'esqueci':                contador_esquecidos += 1            else:                break        bebe = self.medicacao.bebe        if contador_esquecidos >= 3:            descricao = f"3 ou mais doses esquecidas consecutivas para {self.medicacao.nome}"            Alerta.objects.create(bebe=bebe, tipo='vermelho', descricao=descricao, status='pendente')        elif contador_esquecidos == 2:            descricao = f"2 doses esquecidas consecutivas para {self.medicacao.nome}"            # evitar duplicação idempotente: checar se alerta igual pendente já existe            if not Alerta.objects.filter(bebe=bebe, tipo='amarelo', descricao__icontains=self.medicacao.nome, status='pendente').exists():                Alerta.objects.create(bebe=bebe, tipo='amarelo', descricao=descricao, status='pendente')class Alerta(models.Model):    bebe = models.ForeignKey(Bebe, on_delete=models.CASCADE, related_name="alertas")    tipo = models.CharField(max_length=20, choices=TIPO_ALERTA)    descricao = models.TextField()    data_criacao = models.DateTimeField(auto_now_add=True)    status = models.CharField(max_length=20, default='pendente')  # pendente, resolvido    def __str__(self):        return f"[{self.tipo}] {self.bebe.nome} - {self.descricao[:60]}"